#mu iteration
for(j in 1:10){
# j = 1
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
init_grad_mu = eval(Gmu)
diag(init_hmat_mu) = eval(Hmu)
new_mu = old_mu - tryCatch(solve(init_hmat_mu+rhodtd),
error = function(e){solve(init_hmat_mu+ rhodtd + diag(tol,nrow(init_hmat_mu)))})%*%
(init_grad_mu + sec_term %*%(dmatrix%*%old_mu - z_init + u_init))
old_mu = new_mu
}
#sigma, k iteration
for (i in 1:10) {
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
gvec_sk = apply(eval(Gtheta),2,sum)
hmat_sk = matrix(apply(eval(Htheta),2,sum),2,2)
new_sk = old_sk - stepsize *tryCatch(solve(hmat_sk),
error = function(e){solve(hmat_sk +diag(tol,nrow(hmat_sk)))}) %*% gvec_sk
old_sk = new_sk
}
}
# kkt condition - mu,theta
if(iter %% 10 == 0){
mu = old_mu; sigma = old_sk[1]; k = old_sk[2]
# mu check
kkt_mu = eval(Gmu) + sec_term %*% (dmatrix %*% mu -z_init + u_init)
# theta check
kkt_theta = apply(eval(Gtheta),2,sum)
cat("**iter::",iter,"\n")
cat("current_mu::", max(mu), min(mu),"\n")
cat("mu_gradient::", max(kkt_mu), min(kkt_mu),"\n")
cat("theta_gradient::", max(kkt_theta), min(kkt_theta),'\n')
}
# z update in ADMM
tmp_z = func_z(dmatrix = dmatrix, mu = old_mu, u = u_init,lam = lam, rho = rho)
# kkt condition - z check
if(iter %% 10 ==0){
kkt_z = rho * (tmp_z - dmatrix %*% mu - u_init)
cat("z_gradient::",max(kkt_z),min(kkt_z),'\n',"#######################################","\n")
}
# u update in ADMM
tmp_u = func_u(dmatrix = dmatrix , mu = old_mu, z = tmp_z, u = u_init)
u_init = tmp_u ; z_init = tmp_z
}
plot(new_mu,type = "l",main = "symbolic")
paste0("a","b")
paste0(a,b)
paste0("a","b")
?paste0
h
iter
paste0("lambda = ",lam)
paste0("lambda = ",lam, ", symbolic")
plot(new_mu,type = "l",main = paste0("lambda = ",lam, ", symbolic"))
plot(new_mu,type = "l",main = paste0(" symbolic ,", lambda = ",lam))
plot(new_mu,type = "l",main = paste0(" symbolic ,", "lambda = ",lam))
plot(new_mu,type = "l",main = paste0(" symbolic ,",  "lambda = ",lam))
rm(list = ls())
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("3_update_gev_function.R")
n = 500
true_vec = c(100,30,0.1)
#sin function
set.seed(1)
y = sin(seq(0,2*pi,length.out = n)); mt = y +100
x = rep(0,n)
for (i in 1:n) {
# i = 1
x[i] = rgev(1,loc = mt[i],scale = true_vec[2],shape = true_vec[3])
}
# init value
old_mu = mt
old_sk = c(30,0.1) #(40,0.1)
stepsize = 0.01
dmatrix = mat_func(n)
rho = 0.5; lam = 50 ; tol = 1e-08
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
init_hmat_mu = matrix(0,n,n)
sec_term = rho * t(dmatrix); rhodtd = sec_term %*% dmatrix
# derivatives for mles
Gmu = Deriv(logl,"mu"); Hmu = Deriv(logl,"mu",n=c(hessian=2))
Gtheta = Deriv(logl,c("sigma","k"),combine = "cbind")
Htheta = Deriv(logl,c("sigma","k"),n=c(hessian=2),combine = "cbind")
#update
for (iter in 1:400) {
# cat("*****iter:::", iter, "\n")
#mu, sigma, k iteration
for (h in 1:10) {
#mu iteration
for(j in 1:10){
# j = 1
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
init_grad_mu = eval(Gmu)
diag(init_hmat_mu) = eval(Hmu)
new_mu = old_mu - tryCatch(solve(init_hmat_mu+rhodtd),
error = function(e){solve(init_hmat_mu+ rhodtd + diag(tol,nrow(init_hmat_mu)))})%*%
(init_grad_mu + sec_term %*%(dmatrix%*%old_mu - z_init + u_init))
old_mu = new_mu
}
#sigma, k iteration
for (i in 1:10) {
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
gvec_sk = apply(eval(Gtheta),2,sum)
hmat_sk = matrix(apply(eval(Htheta),2,sum),2,2)
new_sk = old_sk - stepsize *tryCatch(solve(hmat_sk),
error = function(e){solve(hmat_sk +diag(tol,nrow(hmat_sk)))}) %*% gvec_sk
old_sk = new_sk
}
}
# kkt condition - mu,theta
# if(iter %% 10 == 0){
#   mu = old_mu; sigma = old_sk[1]; k = old_sk[2]
#
#   # mu check
#   kkt_mu = eval(Gmu) + sec_term %*% (dmatrix %*% mu -z_init + u_init)
#   # theta check
#   kkt_theta = apply(eval(Gtheta),2,sum)
#
#   cat("**iter::",iter,"\n")
#   cat("current_mu::", max(mu), min(mu),"\n")
#   cat("mu_gradient::", max(kkt_mu), min(kkt_mu),"\n")
#   cat("theta_gradient::", max(kkt_theta), min(kkt_theta),'\n')
# }
# z update in ADMM
tmp_z = func_z(dmatrix = dmatrix, mu = old_mu, u = u_init,lam = lam, rho = rho)
# kkt condition - z check
if(iter %% 10 ==0){
# kkt_z = rho * (tmp_z - dmatrix %*% mu - u_init)
# cat("z_gradient::",max(kkt_z),min(kkt_z),'\n',"#######################################","\n")
plot(new_mu,type = "l",main = paste0("iter:",iter))
}
# u update in ADMM
tmp_u = func_u(dmatrix = dmatrix , mu = old_mu, z = tmp_z, u = u_init)
u_init = tmp_u ; z_init = tmp_z
}
rm(list = ls())
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("3_update_gev_function.R")
n = 100
true_vec = c(100,30,0.1)
#sin function
set.seed(1)
y = sin(seq(0,2*pi,length.out = n)); mt = y +100
x = rep(0,n)
for (i in 1:n) {
# i = 1
x[i] = rgev(1,loc = mt[i],scale = true_vec[2],shape = true_vec[3])
}
# init value
old_mu = mt
old_sk = c(30,0.1) #(40,0.1)
stepsize = 0.01
dmatrix = mat_func(n)
rho = 0.5; lam = 1000000 ; tol = 1e-08
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
init_hmat_mu = matrix(0,n,n)
sec_term = rho * t(dmatrix); rhodtd = sec_term %*% dmatrix
# derivatives for mles
Gmu = Deriv(logl,"mu"); Hmu = Deriv(logl,"mu",n=c(hessian=2))
Gtheta = Deriv(logl,c("sigma","k"),combine = "cbind")
Htheta = Deriv(logl,c("sigma","k"),n=c(hessian=2),combine = "cbind")
#update
for (iter in 1:400) {
# cat("*****iter:::", iter, "\n")
#mu, sigma, k iteration
for (h in 1:10) {
#mu iteration
for(j in 1:10){
# j = 1
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
init_grad_mu = eval(Gmu)
diag(init_hmat_mu) = eval(Hmu)
new_mu = old_mu - tryCatch(solve(init_hmat_mu+rhodtd),
error = function(e){solve(init_hmat_mu+ rhodtd + diag(tol,nrow(init_hmat_mu)))})%*%
(init_grad_mu + sec_term %*%(dmatrix%*%old_mu - z_init + u_init))
old_mu = new_mu
}
#sigma, k iteration
for (i in 1:10) {
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
gvec_sk = apply(eval(Gtheta),2,sum)
hmat_sk = matrix(apply(eval(Htheta),2,sum),2,2)
new_sk = old_sk - stepsize *tryCatch(solve(hmat_sk),
error = function(e){solve(hmat_sk +diag(tol,nrow(hmat_sk)))}) %*% gvec_sk
old_sk = new_sk
}
}
# kkt condition - mu,theta
# if(iter %% 10 == 0){
#   mu = old_mu; sigma = old_sk[1]; k = old_sk[2]
#
#   # mu check
#   kkt_mu = eval(Gmu) + sec_term %*% (dmatrix %*% mu -z_init + u_init)
#   # theta check
#   kkt_theta = apply(eval(Gtheta),2,sum)
#
#   cat("**iter::",iter,"\n")
#   cat("current_mu::", max(mu), min(mu),"\n")
#   cat("mu_gradient::", max(kkt_mu), min(kkt_mu),"\n")
#   cat("theta_gradient::", max(kkt_theta), min(kkt_theta),'\n')
# }
# z update in ADMM
tmp_z = func_z(dmatrix = dmatrix, mu = old_mu, u = u_init,lam = lam, rho = rho)
# kkt condition - z check
if(iter %% 10 ==0){
# kkt_z = rho * (tmp_z - dmatrix %*% mu - u_init)
# cat("z_gradient::",max(kkt_z),min(kkt_z),'\n',"#######################################","\n")
plot(new_mu,type = "l",main = paste0("iter:",iter))
}
# u update in ADMM
tmp_u = func_u(dmatrix = dmatrix , mu = old_mu, z = tmp_z, u = u_init)
u_init = tmp_u ; z_init = tmp_z
}
# plot(new_mu,type = "l",main = paste0(" symbolic ,",  "lambda = ",lam))
rm(list = ls())
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("3_update_gev_function.R")
n = 100
true_vec = c(100,30,0.1)
#sin function
set.seed(1)
y = sin(seq(0,2*pi,length.out = n)); mt = y +100
x = rep(0,n)
for (i in 1:n) {
# i = 1
x[i] = rgev(1,loc = mt[i],scale = true_vec[2],shape = true_vec[3])
}
# init value
old_mu = mt
old_sk = c(30,0.1) #(40,0.1)
stepsize = 0.01
dmatrix = mat_func(n)
rho = 0.5; lam = 0.1 ; tol = 1e-08
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
init_hmat_mu = matrix(0,n,n)
sec_term = rho * t(dmatrix); rhodtd = sec_term %*% dmatrix
# derivatives for mles
Gmu = Deriv(logl,"mu"); Hmu = Deriv(logl,"mu",n=c(hessian=2))
Gtheta = Deriv(logl,c("sigma","k"),combine = "cbind")
Htheta = Deriv(logl,c("sigma","k"),n=c(hessian=2),combine = "cbind")
#update
for (iter in 1:400) {
# cat("*****iter:::", iter, "\n")
#mu, sigma, k iteration
for (h in 1:10) {
#mu iteration
for(j in 1:10){
# j = 1
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
init_grad_mu = eval(Gmu)
diag(init_hmat_mu) = eval(Hmu)
new_mu = old_mu - tryCatch(solve(init_hmat_mu+rhodtd),
error = function(e){solve(init_hmat_mu+ rhodtd + diag(tol,nrow(init_hmat_mu)))})%*%
(init_grad_mu + sec_term %*%(dmatrix%*%old_mu - z_init + u_init))
old_mu = new_mu
}
#sigma, k iteration
for (i in 1:10) {
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
gvec_sk = apply(eval(Gtheta),2,sum)
hmat_sk = matrix(apply(eval(Htheta),2,sum),2,2)
new_sk = old_sk - stepsize *tryCatch(solve(hmat_sk),
error = function(e){solve(hmat_sk +diag(tol,nrow(hmat_sk)))}) %*% gvec_sk
old_sk = new_sk
}
}
# kkt condition - mu,theta
# if(iter %% 10 == 0){
#   mu = old_mu; sigma = old_sk[1]; k = old_sk[2]
#
#   # mu check
#   kkt_mu = eval(Gmu) + sec_term %*% (dmatrix %*% mu -z_init + u_init)
#   # theta check
#   kkt_theta = apply(eval(Gtheta),2,sum)
#
#   cat("**iter::",iter,"\n")
#   cat("current_mu::", max(mu), min(mu),"\n")
#   cat("mu_gradient::", max(kkt_mu), min(kkt_mu),"\n")
#   cat("theta_gradient::", max(kkt_theta), min(kkt_theta),'\n')
# }
# z update in ADMM
tmp_z = func_z(dmatrix = dmatrix, mu = old_mu, u = u_init,lam = lam, rho = rho)
# kkt condition - z check
if(iter %% 10 ==0){
# kkt_z = rho * (tmp_z - dmatrix %*% mu - u_init)
# cat("z_gradient::",max(kkt_z),min(kkt_z),'\n',"#######################################","\n")
plot(new_mu,type = "l",main = paste0("iter:",iter))
}
# u update in ADMM
tmp_u = func_u(dmatrix = dmatrix , mu = old_mu, z = tmp_z, u = u_init)
u_init = tmp_u ; z_init = tmp_z
}
# plot(new_mu,type = "l",main = paste0(" symbolic ,",  "lambda = ",lam))
new_mu
# plot(new_mu,type = "l",main = paste0(" symbolic ,",  "lambda = ",lam))
symbolic = new_mu
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("admmgev.R")
source("update_gev_function.R")
source("3_update_gev_function.R")
rm(list = ls())
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("3_update_gev_function.R")
n = 100
true_vec = c(100,30,0.1)
#sin function
set.seed(1)
y = sin(seq(0,2*pi,length.out = n)); mt = y +100
x = rep(0,n)
for (i in 1:n) {
# i = 1
x[i] = rgev(1,loc = mt[i],scale = true_vec[2],shape = true_vec[3])
}
# init value
old_mu = mt
old_sk = c(30,0.1) #(40,0.1)
stepsize = 0.01
dmatrix = mat_func(n)
rho = 0.5; lam = 0.1 ; tol = 1e-08
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
init_hmat_mu = matrix(0,n,n)
sec_term = rho * t(dmatrix); rhodtd = sec_term %*% dmatrix
# derivatives for mles
Gmu = Deriv(logl,"mu"); Hmu = Deriv(logl,"mu",n=c(hessian=2))
Gtheta = Deriv(logl,c("sigma","k"),combine = "cbind")
Htheta = Deriv(logl,c("sigma","k"),n=c(hessian=2),combine = "cbind")
#update
for (iter in 1:400) {
# cat("*****iter:::", iter, "\n")
#mu, sigma, k iteration
for (h in 1:10) {
#mu iteration
for(j in 1:10){
# j = 1
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
init_grad_mu = eval(Gmu)
diag(init_hmat_mu) = eval(Hmu)
new_mu = old_mu - tryCatch(solve(init_hmat_mu+rhodtd),
error = function(e){solve(init_hmat_mu+ rhodtd + diag(tol,nrow(init_hmat_mu)))})%*%
(init_grad_mu + sec_term %*%(dmatrix%*%old_mu - z_init + u_init))
old_mu = new_mu
}
#sigma, k iteration
for (i in 1:10) {
mu = old_mu; sigma=old_sk[1]; k=old_sk[2]
gvec_sk = apply(eval(Gtheta),2,sum)
hmat_sk = matrix(apply(eval(Htheta),2,sum),2,2)
new_sk = old_sk - stepsize *tryCatch(solve(hmat_sk),
error = function(e){solve(hmat_sk +diag(tol,nrow(hmat_sk)))}) %*% gvec_sk
old_sk = new_sk
}
}
# kkt condition - mu,theta
# if(iter %% 10 == 0){
#   mu = old_mu; sigma = old_sk[1]; k = old_sk[2]
#
#   # mu check
#   kkt_mu = eval(Gmu) + sec_term %*% (dmatrix %*% mu -z_init + u_init)
#   # theta check
#   kkt_theta = apply(eval(Gtheta),2,sum)
#
#   cat("**iter::",iter,"\n")
#   cat("current_mu::", max(mu), min(mu),"\n")
#   cat("mu_gradient::", max(kkt_mu), min(kkt_mu),"\n")
#   cat("theta_gradient::", max(kkt_theta), min(kkt_theta),'\n')
# }
# z update in ADMM
tmp_z = func_z(dmatrix = dmatrix, mu = old_mu, u = u_init,lam = lam, rho = rho)
# kkt condition - z check
if(iter %% 10 ==0){
# kkt_z = rho * (tmp_z - dmatrix %*% mu - u_init)
# cat("z_gradient::",max(kkt_z),min(kkt_z),'\n',"#######################################","\n")
plot(new_mu,type = "l",main = paste0("iter:",iter))
}
# u update in ADMM
tmp_u = func_u(dmatrix = dmatrix , mu = old_mu, z = tmp_z, u = u_init)
u_init = tmp_u ; z_init = tmp_z
}
# plot(new_mu,type = "l",main = paste0(" symbolic ,",  "lambda = ",lam))
symbolic = new_mu
# optim control
optim_controlList = list()
optim_controlList$maxit = 1e+3
#set value
n = 100
true_theta=c(30,0.1)
true_beta = rep(0,n)
y = sin(seq(0,2*pi,length = n))*10; mt = y +100  #sin
x= rep(0,n); set.seed(1)
for (i in 1:n) {
x[i] = rgev(1,loc =mt[i],scale=true_theta[1],shape=true_theta[2])
}
z = diag(n)
# init value
dmatrix = mat_func(n)
rho = 0.5;lam = 0.1
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
stepsize = 0.01
start <- list()
start$scale <- sqrt(6 * var(x))/pi
start$loc <- mean(x) - 0.58 * start$scale #이거......
tvec = c(true_beta,0,0)
tvec[1:n] = start$loc  #init mu value
tvec[n+1] = start$scale #init sigma value
old_sk
symbolic_sk = old_sk
symbolic_sk
start <- list()
start$scale <- sqrt(6 * var(x))/pi
start$loc <- mean(x) - 0.58 * start$scale #이거......
tvec = c(true_beta,0,0)
tvec[1:n] = start$loc  #init mu value
tvec[n+1] = start$scale #init sigma value
#update
for (iter in 1:400) {
# cat("*****iter:::", iter, "\n")
#mu, sigma, k optim
old_tvec = gevreg(x = x,z = z)
old_mu = old_tvec[1:n]
# z update in ADMM
tmp_z = func_z(dmatrix = dmatrix, mu = old_mu, u = u_init,lam = lam, rho = rho)
# u update in ADMM
tmp_u = func_u(dmatrix = dmatrix , mu = old_mu, z = tmp_z, u = u_init)
u_init = tmp_u ; z_init = tmp_z
tvec = old_tvec
}
plot(old_mu, type = "l",main = "optim")
data.frame(symbolic = symbolic, optim = optim_mu )
optim_mu=old_mu
data.frame(symbolic = symbolic, optim = optim_mu )
data.frame(symbolic = symbolic_sk, optim = tvec)
tvec
tvec[:2]
tvec[,:2]
tvec[2]
data.frame(symbolic = symbolic_sk, optim = tvec[2:])
tvec[,2:]
tvec[2:]
tvec[2:,]
tvec[n-2:n]
n
tvec[n]
tvec
tvec[-1:-2]
tvec[1:2]
tvec[1:2]
a = c(1,2,3,4,5)
a[1]
a[-1]
a[-1:-2]
a[length(a)]
a[length(a)-1:length(a)]
length(a)
length(a)-1
a[(length(a)-1):length(a)]
data.frame(symbolic = symbolic_sk, optim = tvec[(length(tvec)-1):length(tvec)])
optim_controlList = list()
optim_controlList$maxit = 1e+3
#set value
n = 100
true_theta=c(30,0.1)
true_beta = rep(0,n)
y = sin(seq(0,2*pi,length = n))*10; mt = y +100  #sin
x= rep(0,n); set.seed(1)
for (i in 1:n) {
x[i] = rgev(1,loc =mt[i],scale=true_theta[1],shape=true_theta[2])
}
z = diag(n)
# init value
dmatrix = mat_func(n)
rho = 0.5;lam = 0.1
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
start <- list()
start$scale <- sqrt(6 * var(x))/pi
start
start$loc <- mean(x) - 0.58 * start$scale #이거......
tvec = c(true_beta,0,0)
tvec[1:n] = start$loc  #init mu value
tvec
tvec[n+1] = start$scale #init sigma value
tvec
tvec[(n+1):(n+2)]
rm(list = ls())
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("3_update_gev_function.R")
# optim control
optim_controlList = list()
optim_controlList$maxit = 1e+3
#set value
n = 100
true_theta=c(30,0.1)
true_beta = rep(0,n)
set.seed(1)
y = sin(seq(0,2*pi,length = n))*10; mt = y +100  #sin
x= rep(0,n)
for (i in 1:n) {
x[i] = rgev(1,loc =mt[i],scale=true_theta[1],shape=true_theta[2])
}
x
optim = x
optim
n = 100
true_vec = c(100,30,0.1)
#sin function
set.seed(1)
y = sin(seq(0,2*pi,length.out = n)); mt = y +100
x = rep(0,n)
for (i in 1:n) {
# i = 1
x[i] = rgev(1,loc = mt[i],scale = true_vec[2],shape = true_vec[3])
}
cbind(x,optim)
