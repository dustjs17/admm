pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/3)
arrow3d(p0 = c(0,0,0), p1 = haty,n=1,width = 1/3)
?points3d
dim(sample.beta)[1]
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
# row.names(cx) = c("i","j","k")
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red")
rm(list = ls())
x1 = c(5,7,10); x2 = c(1,3,5)
set.seed(1)
y
y = 2*x1 + x2 + rnorm(3,0,20)
y
haty = 2*x1 + x2
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
# row.names(cx) = c("i","j","k")
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/3)
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red");points3d(0,0,0, col = "black")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/3)
arrow3d(p0 = c(0,0,0), p1 = haty,n=1,width = 1/3)
rm(list = ls())
x1 = c(5,7,10); x2 = c(1,3,5)
set.seed(1)
y = 2*x1 + x2 + rnorm(3,0,20)
y
y
lm(y~x + 0 )
lm(y~x1 + x2 + 0 )
lmy = lm(y ~ x1 + x2 )
fitted(x1,x2)
x = cbind(x1,x2)
fitted(x)
predict(lmy,x)
x = cbind(x1,x2) %>% as.data.frame()
predict(lmy,x)
haty = predict(lmy,x) %>% as.data.frame()
haty
y
y = 2*x1 + x2 + rnorm(3,0,20)
haty = 2*x1 + x2
haty
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
# row.names(cx) = c("i","j","k")
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red");points3d(0,0,0, col = "black")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/3)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/5)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2)
?arrow3d
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l")
points3d(0,0,0, col = "black")
arrow3d(p0 = c(0,0,0), p1 = haty,n=1,width = 1/3)
rm(list = ls())
x1 = c(5,7,10); x2 = c(1,3,5)
set.seed(1)
y = 2*x1 + x2 + rnorm(3,0,20)
#true model
set.seed(1)
#estimate
fit.y = lm(y ~ x1 + x2)
fit.y
y
#estimate
fit.y = lm(y ~ x1 + x2+ 0)
fit.y
coef(fit.y)
fitted(fit.y,cbind(x1,x2))
y
rm(list = ls())
x1 = c(5,7,10); x2 = c(1,3,5)
#true model
set.seed(1)
y = 2*x1 + x2 + rnorm(3,0,20)
y
#estimate
fit.y = lm(y ~ x1 + x2+ 0)
fitted(fit.y,cbind(x1,x2))
haty = fitted(fit.y,cbind(x1,x2))
haty
haty = fitted(fit.y,cbind(x1,x2)) %>% as.data.frame()
haty
y
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red");points3d(0,0,0, col = "black")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l")
points3d(0,0,0, col = "black")
arrow3d(p0 = c(0,0,0), p1 = haty,n=1,width = 1/3)
haty = fitted(fit.y,cbind(x1,x2)) %>% c()
arrow3d(p0 = c(0,0,0), p1 = haty ,n=1,width = 1/3)
arrow3d(p0 = haty, p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l",col = "blue")
haty = predict(fit.y,cbind(x1,x2)) %>% c()
x = cbind(x1,x2)
haty = predict(fit.y,x) %>% c()
x = cbind(x1,x2) %>% as.data.frame()
haty = predict(fit.y,x) %>% c()
haty
y
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
pch = 19, cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red");points3d(0,0,0, col = "black")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l")
points3d(0,0,0, col = "black")
arrow3d(p0 = haty, p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l",col = "blue")
arrow3d(p0 = c(0,0,0), p1 = haty ,n=1,width = 1/3)
haty = fitted(fit.y,x) %>% c()
haty
y - haty
t(y - haty) * y
t(y - haty) %*% y
t(y - haty) %*% haty
rm(list = ls())
x1 = c(5,7,10); x2 = c(1,3,5)
#true model
set.seed(1)
y = 2*x1 + x2 + rnorm(3,0,20)
#estimate
fit.y = lm(y ~ x1 + x2+ 0)
x = cbind(x1,x2) %>% as.data.frame()
haty = predict(fit.y,x) %>% c()
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3") %>%
points3d(y[1],y[2], y[3],col = "red",cex = 2) %>%
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l") %>%
arrow3d(p0 = haty, p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l",col = "blue") %>%
arrow3d(p0 = c(0,0,0), p1 = haty ,n=1,width = 1/3)
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red",cex = 2)
points3d(y[1],y[2], y[3],col = "red",cex = 3)
points3d(y[1],y[2], y[3],col = "red",cex = 4)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "rotation")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red",cex = 4)
points3d(y[1],y[2], y[3],col = "red",cex = 4)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,thickness = 0.2,type = "rotation")
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,type = "rotation")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red",cex = 4)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,type = "rotation")
y
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,type = "l")
arrow3d(p0 = haty, p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l",col = "blue")
arrow3d(p0 = c(0,0,0), p1 = haty ,n=1,width = 1/3)
t(y - haty) %*% haty
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
rm(list = ls())
x1 = c(5,7,10); x2 = c(1,3,5)
#true model
set.seed(1)
y = 2*x1 + x2 + rnorm(3,0,20)
#fit
fit.y = lm(y ~ x1 + x2+ 0)
x = cbind(x1,x2) %>% as.data.frame()
haty = predict(fit.y,x) %>% c()
#generate beta
beta1 = seq(-5,5); beta2 = seq(-5,5)
sample.beta = expand.grid(beta1 = beta1, beta2 = beta2)
cx = matrix(0,nrow = 3,ncol = dim(sample.beta)[1])
for (i in 1:dim(sample.beta)[1]) {
cx[,i] = sample.beta[i,1] * x1 + sample.beta[i,2]*x2
}
#graph
library("rgl")
plot3d(x = cx[1, ],y = cx[2, ],z = cx[3, ],phi = 0, bty = "g", col = "gray", type = "l",
cex = 1, ticktype = "detailed",xlab = "y1",ylab = "y2",zlab = "y3")
points3d(y[1],y[2], y[3],col = "red",cex = 4)
arrow3d(p0 = c(0,0,0), p1 = y,n=1,width = 1/10,type = "l")
arrow3d(p0 = haty, p1 = y,n=1,width = 1/10,thickness = 0.2,type = "l",col = "blue")
arrow3d(p0 = c(0,0,0), p1 = haty ,n=1,width = 1/3)
#check inner product
t(y - haty) %*% haty
1/1,2262
1/1,2262
1/1.2262
if(!require(Deriv)){install.packages("Deriv")};library(Deriv)
if(!require(evd)){install.packages("evd")};library(evd)
n = 100
true_theta=c(30,0.1)
true_beta = rep(0,n)
y = sin(seq(0,2*pi,length = n))*10; mt = y +100  #sin
x= rep(0,n); set.seed(1)
for (i in 1:n) {
x[i] = rgev(1,loc =mt[i],scale=true_theta[1],shape=true_theta[2])
}
z = diag(n)
# init value
dmatrix = mat_func(n)
rho = 0.5;lam = 2
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
stepsize = 0.01
start <- list()
start$scale <- sqrt(6 * var(x))/pi
start$loc <- mean(x) - 0.58 * start$scale #이거......
tvec = c(true_beta,0,0)
tvec[1:n] = start$loc  #init mu value
tvec[n+1] = start$scale #init sigma value
l2gev = function (tvec, dmatrix, rho, z_init, u_init)
{
# loc.vec = zz%*%tvec[1:(p+1)]
loc.vec = tvec[1:n]
# loglikelihood
v1 = - sum(lgev(x, loc = loc.vec, scale = tvec[n+1], shape = tvec[n+2]))
# lagrangian term
v2 = (rho/2)*sum(((dmatrix %*% loc.vec) - z_init + u_init)^2)
v = v1 + v2
return(v)
}
lgev = function (x, loc = 0, scale = 1, shape = 0)
{
if (min(scale) <= 0)
return( - 1e+6)
if (length(shape) != 1)
stop("invalid shape")
x <- (x - loc)/scale
if (shape == 0)
d <- log(1/scale) - x - exp(-x)
else {
nn <- length(x)
xx <- 1 + shape * x
xxpos <- xx[xx > 0 | is.na(xx)]
scale <- rep(scale, length.out = nn)[xx > 0 | is.na(xx)]
d <- numeric(nn)
d[xx > 0 | is.na(xx)] <- log(1/scale) - xxpos^(-1/shape) -
(1/shape + 1) * log(xxpos)
d[xx <= 0 & !is.na(xx)] <- -(1e+6)
}
return(d)
}
optim_loss = optim(tvec, l2gev, dmatrix = dmatrix,
rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")
#dmatrix
mat_func = function(n) {
m = matrix(0,n-2,n)   ## dmatrix : (n-2)*n
for (i in 1:(n-2)) {
m[i,i] = 1
m[i,i+1] = -2
m[i,i+2] = 1
}
return(m)
}
# init value
dmatrix = mat_func(n)
l2gev = function (tvec, dmatrix, rho, z_init, u_init)
{
# loc.vec = zz%*%tvec[1:(p+1)]
loc.vec = tvec[1:n]
# loglikelihood
v1 = - sum(lgev(x, loc = loc.vec, scale = tvec[n+1], shape = tvec[n+2]))
# lagrangian term
v2 = (rho/2)*sum(((dmatrix %*% loc.vec) - z_init + u_init)^2)
v = v1 + v2
return(v)
}
lgev = function (x, loc = 0, scale = 1, shape = 0)
{
if (min(scale) <= 0)
return( - 1e+6)
if (length(shape) != 1)
stop("invalid shape")
x <- (x - loc)/scale
if (shape == 0)
d <- log(1/scale) - x - exp(-x)
else {
nn <- length(x)
xx <- 1 + shape * x
xxpos <- xx[xx > 0 | is.na(xx)]
scale <- rep(scale, length.out = nn)[xx > 0 | is.na(xx)]
d <- numeric(nn)
d[xx > 0 | is.na(xx)] <- log(1/scale) - xxpos^(-1/shape) -
(1/shape + 1) * log(xxpos)
d[xx <= 0 & !is.na(xx)] <- -(1e+6)
}
return(d)
}
optim_loss = optim(tvec, l2gev, dmatrix = dmatrix,
rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")
optim_loss
if(!require(Deriv)){install.packages("Deriv")};library(Deriv)
if(!require(evd)){install.packages("evd")};library(evd)
#loss function
logl=expression(log(sigma)+(1+1/k)*log(1+k*(x-mu)/sigma)+(1+k*(x-mu)/sigma)^(-1/k))
func_loss = function()
#z_function
func_z <- function(dmatrix,mu,u,lam,rho)
{
z = ifelse(abs(dmatrix %*% mu + u) > (lam/rho) ,
(dmatrix %*% mu) + u - sign(u + (dmatrix %*% mu)) * (lam /rho), 0)
return(z)
}
#u_function
func_u <- function(dmatrix,mu,z,u)
{
u <- u + (dmatrix %*% mu) - z
return(u)
}
#dmatrix
mat_func = function(n) {
m = matrix(0,n-2,n)   ## dmatrix : (n-2)*n
for (i in 1:(n-2)) {
m[i,i] = 1
m[i,i+1] = -2
m[i,i+2] = 1
}
return(m)
}
## gevfunction
gevreg = function(x, z)
{
l2gev = function (tvec, dmatrix, rho, z_init, u_init)
{
# loc.vec = zz%*%tvec[1:(p+1)]
loc.vec = tvec[1:n]
# loglikelihood
v1 = - sum(lgev(x, loc = loc.vec, scale = tvec[n+1], shape = tvec[n+2]))
# lagrangian term
v2 = (rho/2)*sum(((dmatrix %*% loc.vec) - z_init + u_init)^2)
v = v1 + v2
return(v)
}
lgev = function (x, loc = 0, scale = 1, shape = 0)
{
if (min(scale) <= 0)
return( - 1e+6)
if (length(shape) != 1)
stop("invalid shape")
x <- (x - loc)/scale
if (shape == 0)
d <- log(1/scale) - x - exp(-x)
else {
nn <- length(x)
xx <- 1 + shape * x
xxpos <- xx[xx > 0 | is.na(xx)]
scale <- rep(scale, length.out = nn)[xx > 0 | is.na(xx)]
d <- numeric(nn)
d[xx > 0 | is.na(xx)] <- log(1/scale) - xxpos^(-1/shape) -
(1/shape + 1) * log(xxpos)
d[xx <= 0 & !is.na(xx)] <- -(1e+6)
}
return(d)
}
optim_loss = optim(tvec, l2gev, dmatrix = dmatrix,
rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")
return(optim_loss)
# return( optim(tvec, l2gev, dmatrix = dmatrix,
#rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")$par )
}
rm(list = ls())
if(!require(Deriv)){install.packages("Deriv")};library(Deriv)
if(!require(evd)){install.packages("evd")};library(evd)
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("admmgev.R")
# optim control
optim_controlList = list()
optim_controlList$maxit = 1e+3
#set value
n = 100
true_theta=c(30,0.1)
true_beta = rep(0,n)
y = sin(seq(0,2*pi,length = n))*10; mt = y +100  #sin
x= rep(0,n); set.seed(1)
for (i in 1:n) {
x[i] = rgev(1,loc =mt[i],scale=true_theta[1],shape=true_theta[2])
}
z = diag(n)
# init value
dmatrix = mat_func(n)
rho = 0.5;lam = 2
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
stepsize = 0.01
start <- list()
start$scale <- sqrt(6 * var(x))/pi
start$loc <- mean(x) - 0.58 * start$scale #이거......
tvec = c(true_beta,0,0)
tvec[1:n] = start$loc  #init mu value
tvec[n+1] = start$scale #init sigma value
gevreg(x = x,z = z)$par
gevreg(x = x,z = z)
rm(list = ls())
if(!require(Deriv)){install.packages("Deriv")};library(Deriv)
if(!require(evd)){install.packages("evd")};library(evd)
setwd("C:/Users/UOS/Documents/GitHub/admm")
source("admmgev.R")
# optim control
optim_controlList = list()
optim_controlList$maxit = 1e+3
#set value
n = 100
true_theta=c(30,0.1)
true_beta = rep(0,n)
y = sin(seq(0,2*pi,length = n))*10; mt = y +100  #sin
x= rep(0,n); set.seed(1)
for (i in 1:n) {
x[i] = rgev(1,loc =mt[i],scale=true_theta[1],shape=true_theta[2])
}
z = diag(n)
# init value
dmatrix = mat_func(n)
rho = 0.5;lam = 2
z_init = rep(0,n-2) ; u_init = rep(1,n-2)
stepsize = 0.01
start <- list()
start$scale <- sqrt(6 * var(x))/pi
start$loc <- mean(x) - 0.58 * start$scale #이거......
tvec = c(true_beta,0,0)
tvec[1:n] = start$loc  #init mu value
tvec[n+1] = start$scale #init sigma value
gevreg(x = x,z = z)
gevreg(x = x,z = z)$par
#mu, sigma, k optim
optim_value = gevreg(x = x,z = z)
optim_value$par
old_tvec = optim_value$par
old_mu = old_tvec[1:n]
#rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")$par )
}
## gevfunction
gevreg = function(x, z)
{
l2gev = function (tvec, dmatrix, rho, z_init, u_init)
{
# loc.vec = zz%*%tvec[1:(p+1)]
loc.vec = tvec[1:n]
# loglikelihood
v1 = - sum(lgev(x, loc = loc.vec, scale = tvec[n+1], shape = tvec[n+2]))
# lagrangian term
v2 = (rho/2)*sum(((dmatrix %*% loc.vec) - z_init + u_init)^2)
v = v1 + v2
return(v)
}
lgev = function (x, loc = 0, scale = 1, shape = 0)
{
if (min(scale) <= 0)
return( - 1e+6)
if (length(shape) != 1)
stop("invalid shape")
x <- (x - loc)/scale
if (shape == 0)
d <- log(1/scale) - x - exp(-x)
else {
nn <- length(x)
xx <- 1 + shape * x
xxpos <- xx[xx > 0 | is.na(xx)]
scale <- rep(scale, length.out = nn)[xx > 0 | is.na(xx)]
d <- numeric(nn)
d[xx > 0 | is.na(xx)] <- log(1/scale) - xxpos^(-1/shape) -
(1/shape + 1) * log(xxpos)
d[xx <= 0 & !is.na(xx)] <- -(1e+6)
}
return(d)
}
# optim_loss = optim(tvec, l2gev, dmatrix = dmatrix,
#                   rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")
# return(optim_loss)
return( optim(tvec, l2gev, dmatrix = dmatrix,
rho=rho, z_init = z_init, u_init = u_init, method = "BFGS")$par )
}
